load("@rules_elixir//:elixir_app.bzl", "elixir_app")
load("@rules_elixir//:ex_unit_test.bzl", "ex_unit_test")
load("@rules_erlang//:escript.bzl", "escript_archive")

load("@rules_elixir//:defs.bzl", "mix_library", "mix_release")

mix_library(
    name = "lib",
    # TODO: we should generate this target, and elicit this name from the mix
    # configuration
    app_name = "plug_sample",
    mix_config = ":mix.exs",
    srcs = glob(['lib/**/*.ex']),
    deps = [
        "@plug_crypto//:plug_crypto"
    ],
)

mix_release(
    name = "bin",
    application = ":lib",
)

# TODO: this is what we want mix_binary to look like, when mix_release has
# been built separately (for whatever reason)
# mix_binary(
#     name = "basic-bin",
#     release = ":basic-release",
# )

# Otherwise, we should still be able to construct this without _explicitly_
# defining a mix_release. maybe this just becomes a macro?
# mix_binary(
#     name = "basic-bin",
#     application = ":basic",
# )

# elixir_app(
#     app_name = "basic",
#     srcs = [
#         "mix.exs",
#     ] + glob(["lib/**/*.ex"]),
# )
# 
# escript_archive(
#     name = "basic",
#     app = ":erlang_app",
#     headers = [
#         "shebang",
#         '{emu_args, "-escript main Elixir.Basic -hidden"}',
#     ],
# )
# 
# ex_unit_test(
#     name = "assertion_test",
#     srcs = [
#         "test/assertion_test.exs",
#     ],
#     env = {
#         "ERL_COMPILER_OPTIONS": "deterministic",
#         "ELIXIR_ERL_OPTIONS": "+fnu",
#     },
# )
# 
# ex_unit_test(
#     name = "helped_test",
#     srcs = [
#         "test/test_helper.exs",
#         "test/helped_test.exs",
#     ],
#     env = {
#         "ERL_COMPILER_OPTIONS": "deterministic",
#         "ELIXIR_ERL_OPTIONS": "+fnu",
#     },
# )
