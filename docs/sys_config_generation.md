# sys.config Generation for Elixir Releases

This document explains how to generate `sys.config` files for Erlang/Elixir releases built with Bazel, including support for runtime configuration via Config.Provider.

## Overview

The `elixir_sys_config` rule generates Erlang `sys.config` files that:
1. Include compile-time configuration from EETF files
2. Optionally set up Config.Provider for runtime configuration
3. Integrate with boot scripts to automatically call `Config.Provider.boot()`

## Basic Usage

### Compile-Time Configuration Only

For applications that only need compile-time configuration:

```python
# BUILD.bazel

# First, extract compile-time config
eval_config(
    name = "my_app_config",
    app = "my_app",
    config_files = glob(["config/*.exs"]),
)

# Generate sys.config
elixir_sys_config(
    name = "sys_config",
    app_configs = [
        ":my_app_config",
        "//deps/logger:config",
    ],
    extra_config = {
        "kernel": "[{logger_level, info}]",
    },
)

# Use in release
erlang_release(
    name = "my_release",
    sys_config = ":sys_config",
    # ... other attributes
)
```

### With Runtime Configuration

For applications that need runtime configuration (environment variables, etc.):

```python
elixir_sys_config(
    name = "sys_config",
    app_configs = [
        ":my_app_config",
    ],
    runtime_configs = ["config/runtime.exs"],
    runtime_config_path = "{:system, \"RELEASE_ROOT\", \"/runtime.exs\"}",
    reboot_system_after_config = False,
)
```

## How It Works

### 1. Compile-Time Config Processing

The rule reads EETF files (generated by `eval_config`) containing compile-time configuration and merges them into a single configuration structure.

### 2. Runtime Config Setup

When `runtime_configs` is specified, the rule:
1. Sets up Config.Provider in the sys.config
2. Copies runtime.exs files to the release
3. Configures the provider to evaluate runtime.exs at boot time
4. Generates boot script injection instructions

### 3. Boot Script Integration

To ensure `Config.Provider.boot()` is called automatically (without user code changes), the boot script is modified to include:

```erlang
{apply, {'Elixir.Config.Provider', boot, []}}
```

This is injected after the Elixir application starts but before user applications.

### 4. Boot Sequence

With runtime configuration enabled:
1. VM starts and loads sys.config
2. Core OTP applications start (kernel, stdlib)
3. Elixir application starts
4. **Config.Provider.boot() is called automatically** (from boot script)
5. runtime.exs is evaluated with current environment variables
6. Configuration is merged with compile-time config
7. If `reboot_system_after_config` is true, VM restarts
8. User applications start with final configuration

## Configuration Options

### elixir_sys_config Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| `app_configs` | Label list | EETF config files from `eval_config` |
| `runtime_configs` | Label list | Runtime config files (e.g., runtime.exs) |
| `runtime_config_path` | String | Path template for runtime config at runtime |
| `reboot_system_after_config` | Boolean | Whether to restart VM after loading config |
| `prune_runtime_sys_config_after_boot` | Boolean | Delete temporary config files after boot |
| `validate_compile_env` | String list | Compile-time config validations |
| `extra_config` | String dict | Additional static configuration |

### Runtime Path Templates

The `runtime_config_path` can be:
- Absolute path: `"/opt/app/runtime.exs"`
- Environment variable path: `{:system, "RELEASE_ROOT", "/runtime.exs"}`

The {:system, ...} format concatenates the environment variable value with the path.

## Generated Files

### sys.config Structure

```erlang
%% coding: utf-8
%% RUNTIME_CONFIG=true
[
  %% Compile-time configs
  {my_app, [
    {port, 8080},
    {compile_flag, true}
  ]},

  %% Config.Provider setup (if runtime config enabled)
  {elixir, [
    {config_provider_init,
      {'Elixir.Config.Provider', [
        {providers, [{'Elixir.Config.Reader', ...}]},
        {config_path, {system, <<"RELEASE_SYS_CONFIG">>, <<".config">>}},
        {reboot_system_after_config, false},
        ...
      ]}
    }
  ]}
].
```

### Boot Injection File

When runtime config is enabled, a `.boot_inject` file is generated with instructions for modifying the boot script.

## Complete Example

### Project Structure

```
my_app/
├── config/
│   ├── config.exs      # Compile-time config
│   ├── prod.exs        # Production compile-time config
│   └── runtime.exs     # Runtime config (env vars)
├── lib/
│   └── my_app.ex
└── BUILD.bazel
```

### config/runtime.exs

```elixir
import Config

# Runtime configuration using environment variables
config :my_app,
  database_url: System.get_env("DATABASE_URL"),
  secret_key: System.get_env("SECRET_KEY_BASE"),
  port: String.to_integer(System.get_env("PORT", "4000"))

config :logger,
  level: String.to_atom(System.get_env("LOG_LEVEL", "info"))
```

### BUILD.bazel

```python
load("//private:elixir_sys_config.bzl", "elixir_sys_config")
load("//tools/eval_config:eval_config.bzl", "eval_config")

# Extract compile-time config
eval_config(
    name = "compile_config",
    app = "my_app",
    env = "prod",
    config_files = glob(["config/*.exs"]),
)

# Generate sys.config with runtime support
elixir_sys_config(
    name = "sys_config",
    app_configs = [":compile_config"],
    runtime_configs = ["config/runtime.exs"],
    runtime_config_path = "{:system, \"RELEASE_ROOT\", \"/config/runtime.exs\"}",
    reboot_system_after_config = False,  # Don't need to restart for app config
    prune_runtime_sys_config_after_boot = True,  # Clean up temp files
)

# Build release with sys.config
erlang_release(
    name = "release",
    sys_config = ":sys_config",
    apps = [":my_app"],
    # ... other attributes
)
```

## Testing

Test your sys.config generation:

```bash
# Build the sys.config
bazel build //my_app:sys_config

# Verify it's valid Erlang syntax
erl -noshell -eval "
  {ok, Config} = file:consult('bazel-bin/my_app/sys_config.sys.config'),
  io:format('Config: ~p~n', [Config]),
  halt(0).
"

# Check for Config.Provider setup (if using runtime config)
grep "config_provider_init" bazel-bin/my_app/sys_config.sys.config
```

## Troubleshooting

### Config Not Loading

1. Verify sys.config is placed at `releases/VERSION/sys.config`
2. Check boot script includes `-config` flag
3. Ensure Config.Provider.boot() is in boot script (for runtime config)

### Runtime Config Not Evaluating

1. Check runtime.exs is copied to release
2. Verify environment variables are set
3. Check Config.Provider is properly initialized in sys.config
4. Look for errors in release logs during boot

### Reboot Issues

If using `reboot_system_after_config: true`:
- Ensure your init system handles restarts
- Check that kernel/stdlib configs aren't being modified
- Consider using `false` if you only configure your own apps

## Migration from Mix Releases

If migrating from Mix releases:

1. **Extract configs**: Use `eval_config` instead of Mix compilation
2. **Generate sys.config**: Use `elixir_sys_config` rule
3. **Runtime config**: Keep your runtime.exs files as-is
4. **Boot scripts**: The Config.Provider.boot() call is handled automatically

## Best Practices

1. **Separate concerns**: Keep compile-time and runtime config separate
2. **Use runtime config sparingly**: Only for true runtime values (env vars, secrets)
3. **Avoid reboots**: Set `reboot_system_after_config: false` unless modifying core OTP apps
4. **Test locally**: Verify sys.config generation before deploying
5. **Cache effectively**: Compile-time configs are cacheable by Bazel

## Limitations

1. **No Mix.env()**: Use explicit environments in eval_config
2. **No imports in runtime.exs**: Config.Provider disables imports for safety
3. **Boot script modification**: Requires cooperation from erlang_release rule

## Future Improvements

- Support for custom Config.Provider implementations
- Multiple runtime config files
- Config validation at build time
- Integration with secrets management systems