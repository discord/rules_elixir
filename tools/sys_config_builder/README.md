# sys_config_builder

Elixir tool for generating `sys.config` files from compiled Elixir configuration.

## What is sys.config?

`sys.config` is Erlang/OTP's standard application configuration file. It's an Erlang term file loaded at VM boot time that provides configuration to OTP applications before they start:

```erlang
[
  {my_app, [
    {port, 4000},
    {host, "localhost"}
  ]},
  {logger, [...]}
].
```

## Erlang vs Elixir Configuration Systems

### Pure Erlang (rules_erlang_2)
- **Format**: Raw Erlang term strings
- **Environments**: No built-in concept (dev/prod/test)
- **Runtime config**: Not supported
- **Generation**: Simple string formatting into sys.config syntax
- **Tool**: `erlang_sys_config` rule - straightforward term-to-file conversion

### Elixir (rules_mix)
- **Format**: Elixir Config DSL (`import Config; config :app, key: value`)
- **Environments**: First-class support (prod/dev/test with separate config files)
- **Runtime config**: Supported via `Config.Provider` protocol
- **Generation**: Multi-phase evaluation and compilation
- **Tool**: `elixir_sys_config` rule + this sys_config_builder tool

### Key Differences

| Aspect | Erlang | Elixir |
|--------|--------|--------|
| Config files | Erlang terms (.config) | Elixir code (.exs) |
| Evaluation | Static file | Compiled/evaluated at build time |
| Runtime config | Not available | Config.Provider support |
| Type complexity | Simple terms | Maps, structs, binaries, complex types |
| Environments | Manual | Automatic (config/prod.exs, config/dev.exs) |

## Why rules_mix Diverges from rules_erlang

### Technical Reasons

1. **Elixir config files are code**: They use Elixir DSL that must be evaluated by the Elixir compiler, not simple term formatting

2. **Environment-based compilation**: Different configurations for prod/dev/test must be evaluated separately with proper environment context

3. **Runtime configuration**: Elixir's `Config.Provider` is not part of Erlang/OTP - it's an Elixir innovation that requires special handling in the boot process

4. **Type complexity**: Elixir configs can contain Elixir Maps (`%{}`), structs (`%MyStruct{}`), and binaries that don't have direct Erlang term equivalents

5. **Binary format**: Configs are compiled to EETF (External Erlang Term Format) for efficient serialization

### Architectural Decision

Attempting to extend `erlang_sys_config` to support Elixir would:
- Pollute rules_erlang_2 with Elixir-specific concepts
- Create an Elixir dependency in pure Erlang rules
- Complicate the simple Erlang use case

Instead, `elixir_sys_config` provides a clean separation:
- `erlang_sys_config`: Simple term formatting for Erlang apps
- `elixir_sys_config`: Full Elixir Config system support

## How sys_config_builder Works

This tool (`sys_config_builder.ex`) processes Elixir configuration in several phases:

### Phase 1: Read Compiled Configs
- Receives EETF files produced by `eval_config` (configs already evaluated in the correct environment)
- Reads binary Erlang term format using `:erlang.binary_to_term/1`

### Phase 2: Merge Configuration Sources
- Intelligently merges multiple config sources (app configs, dependencies, overrides)
- Preserves proper precedence and merge semantics

### Phase 3: Set Up Config.Provider (if runtime config present)
- Creates Config.Provider initialization structure in the elixir app config:
```erlang
{elixir, [
  {config_provider_init, %Config.Provider{
    providers: [{Config.Reader, {runtime_path, []}}],
    config_path: {:system, "RELEASE_SYS_CONFIG", ".config"},
    reboot_system_after_config: false,
    prune_runtime_sys_config_after_boot: true
  }}
]}
```

### Phase 4: Generate sys.config
- Writes final Erlang term file in standard sys.config format
- Includes Config.Provider metadata if runtime configuration is enabled

### Phase 5: Provide Metadata
- Returns `SysConfigInfo` provider with environment, version, and runtime config status
- Used by downstream rules (elixir_release) to determine boot script processing needs

## Why This Tool is Written in Elixir

This tool **must** be written in Elixir because:
1. Must understand Elixir's Config module and structures
2. Must properly handle Elixir types (Maps, structs, etc.)
3. Must read EETF format with Elixir/Erlang type semantics
4. Must understand Config.Provider protocol

Pure Erlang tooling cannot properly handle Elixir-specific configuration structures.

## Integration with Release Building

The sys.config generated by this tool integrates with the release process:

1. **elixir_sys_config** uses this tool to generate sys.config
2. **elixir_release** checks `SysConfigInfo.has_runtime_config`
3. If runtime config present, **boot_script_processor** injects `Config.Provider.boot()` call
4. **elixir_release_bundle** includes sys.config and runtime config files in the release bundle

This ensures runtime configuration is properly initialized at application startup.

## Summary

The divergence between rules_mix and rules_erlang for sys.config generation is **necessary and intentional**:
- Erlang and Elixir have fundamentally different configuration systems
- Elixir's features (environments, runtime config, Config.Provider) require Elixir-specific tooling
- Clean separation maintains simplicity in rules_erlang while providing full functionality in rules_mix
- Follows the same pattern as Mix itself uses for configuration handling
