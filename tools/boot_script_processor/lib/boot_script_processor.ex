defmodule BootScriptProcessor do
  @moduledoc """
  Processes Erlang boot scripts to add Elixir-specific functionality.

  This module implements the same post-processing that Mix applies to
  boot scripts generated by systools:make_script/2, specifically:

  1. Injecting Config.Provider boot call after stdlib starts
  2. Prepending consolidated protocol paths to all :path instructions

  This is designed to be used as an escript from Bazel rules.
  """

  # Escript entry point
  def main(args \\ System.argv()) do
    # Convert charlists to strings if needed (escript issue)
    args = Enum.map(args, fn
      arg when is_list(arg) -> List.to_string(arg)
      arg when is_binary(arg) -> arg
    end)

    case parse_args(args) do
      {:ok, opts} ->
        run(opts)

      {:error, message} ->
        IO.puts(:stderr, "Error: #{message}")
        IO.puts(:stderr, "")
        print_usage()
        System.halt(1)
    end
  end

  defp parse_args(args) do
    {parsed, remaining, invalid} = OptionParser.parse(args,
      strict: [
        input: :string,
        output: :string,
        version: :string,
        consolidated_path: :string,
        no_config_provider: :boolean,
        no_boot: :boolean,
        help: :boolean
      ],
      aliases: [
        i: :input,
        o: :output,
        v: :version,
        c: :consolidated_path,
        h: :help
      ]
    )

    cond do
      parsed[:help] ->
        print_usage()
        System.halt(0)

      length(invalid) > 0 ->
        {:error, "Invalid options: #{inspect(invalid)}"}

      length(remaining) > 0 ->
        {:error, "Unexpected arguments: #{Enum.join(remaining, " ")}"}

      !Keyword.has_key?(parsed, :input) ->
        {:error, "Input file is required (--input or -i)"}

      !Keyword.has_key?(parsed, :output) ->
        {:error, "Output file is required (--output or -o)"}

      true ->
        {:ok, build_opts(parsed)}
    end
  end

  defp build_opts(parsed) do
    %{
      input: parsed[:input],
      output: parsed[:output],
      version: parsed[:version],
      consolidated_path: parsed[:consolidated_path],
      inject_config_provider: !Keyword.get(parsed, :no_config_provider, false),
      generate_boot: !Keyword.get(parsed, :no_boot, false)
    }
  end

  defp run(opts) do
    process_opts = [
      inject_config_provider: opts.inject_config_provider,
      generate_boot: opts.generate_boot
    ]

    # Add version or consolidated_path if provided
    process_opts =
      if opts.consolidated_path do
        Keyword.put(process_opts, :consolidated_path, opts.consolidated_path)
      else
        if opts.version do
          Keyword.put(process_opts, :version, opts.version)
        else
          process_opts
        end
      end

    case process_script_file(opts.input, opts.output, process_opts) do
      :ok ->
        IO.puts("Successfully processed boot script")
        IO.puts("  Input:  #{opts.input}")
        IO.puts("  Output: #{opts.output}")

        if opts.generate_boot do
          boot_file = String.replace_suffix(opts.output, ".script", ".boot")
          IO.puts("  Boot:   #{boot_file}")
        end

      {:error, reason} ->
        IO.puts(:stderr, "Failed to process boot script: #{inspect(reason)}")
        System.halt(1)
    end
  end

  defp print_usage do
    IO.puts("""
    Usage: boot_script_processor [OPTIONS]

    Process Erlang boot scripts for Elixir releases, adding Config.Provider
    support and consolidated protocol paths.

    Required Options:
      -i, --input FILE         Input .script file from systools:make_script
      -o, --output FILE        Output .script file with modifications

    Optional Options:
      -v, --version VERSION    Release version (for consolidated path)
      -c, --consolidated_path  Custom consolidated protocols path
      --no-config-provider     Skip Config.Provider injection
      --no-boot               Skip .boot file generation
      -h, --help              Show this help message

    Examples:

      # Basic processing with version
      boot_script_processor -i myapp.script -o myapp_modified.script -v 1.0.0

      # Custom consolidated path
      boot_script_processor -i myapp.script -o myapp_modified.script \
        --consolidated-path '$RELEASE_LIB/../consolidated'

      # Minimal processing (no Config.Provider)
      boot_script_processor -i myapp.script -o myapp_modified.script \
        --no-config-provider

    Notes:
      - The tool follows Mix's approach to boot script post-processing
      - Config.Provider is injected after stdlib starts
      - Consolidated paths are prepended to all :path instructions
      - A .boot file is generated automatically unless --no-boot is specified
    """)
  end

  @doc """
  Process a boot script file, applying Elixir-specific modifications.

  ## Options

    * `:inject_config_provider` - Whether to inject Config.Provider boot call (default: true)
    * `:consolidated_path` - Path to consolidated protocols directory (optional)
    * `:version` - Release version for consolidated path (required if consolidated_path not provided)

  ## Returns

    * `{:ok, modified_script}` - The modified script term
    * `{:error, reason}` - If processing fails
  """
  def process_script(script_path, opts \\ []) do
    with {:ok, [script_term]} <- :file.consult(to_charlist(script_path)),
         {:ok, modified} <- modify_script(script_term, opts) do
      {:ok, modified}
    else
      {:error, _} = error -> error
      error -> {:error, {:unexpected, error}}
    end
  end

  @doc """
  Write a processed script back to disk.
  """
  def write_script(script_term, output_path) do
    content = :io_lib.format('~tp.~n', [script_term])
    File.write(output_path, content)
  end

  @doc """
  Generate a .boot file from a .script file using systools.
  """
  def script_to_boot(script_path) do
    script_path_charlist = to_charlist(String.replace_suffix(script_path, ".script", ""))
    case :systools.script2boot(script_path_charlist) do
      :ok -> :ok
      {:error, _} = error -> error
    end
  end

  # Private functions

  defp modify_script({:script, {name, vsn}, instructions}, opts) do
    with {:ok, instructions} <- maybe_inject_config_provider(instructions, opts),
         {:ok, instructions} <- maybe_add_consolidated_paths(instructions, opts) do
      {:ok, {:script, {name, vsn}, instructions}}
    end
  end

  defp modify_script(_, _), do: {:error, :invalid_script_format}

  defp maybe_inject_config_provider(instructions, opts) do
    if Keyword.get(opts, :inject_config_provider, true) do
      inject_config_provider(instructions)
    else
      {:ok, instructions}
    end
  end

  defp inject_config_provider(instructions) do
    # Find the index after {:progress, :started} that follows stdlib
    case find_stdlib_started_index(instructions) do
      {:ok, index} ->
        # Insert Config.Provider boot call after stdlib starts
        config_provider_instruction = {:apply, {Config.Provider, :boot, []}}
        updated = List.insert_at(instructions, index + 1, config_provider_instruction)
        {:ok, updated}

      :not_found ->
        # If we can't find the stdlib started marker, continue without injection
        # This handles minimal/embedded releases that might not have stdlib
        {:ok, instructions}
    end
  end

  defp find_stdlib_started_index(instructions) do
    # We need to find {:progress, :started} that comes AFTER stdlib application starts
    # First, find where stdlib starts - it could be :start_boot or :start
    stdlib_index = Enum.find_index(instructions, fn
      {:apply, {:application, :start_boot, [:stdlib | _]}} -> true
      {:apply, {:application, :start, [:stdlib | _]}} -> true
      _ -> false
    end)

    if stdlib_index do
      # Now find the next {:progress, :started} after stdlib
      remaining = Enum.drop(instructions, stdlib_index + 1)
      case Enum.find_index(remaining, &match?({:progress, :started}, &1)) do
        nil -> :not_found
        offset -> {:ok, stdlib_index + 1 + offset}
      end
    else
      :not_found
    end
  end

  defp maybe_add_consolidated_paths(instructions, opts) do
    consolidated_path = get_consolidated_path(opts)

    if consolidated_path do
      add_consolidated_paths(instructions, consolidated_path)
    else
      {:ok, instructions}
    end
  end

  defp get_consolidated_path(opts) do
    case Keyword.get(opts, :consolidated_path) do
      nil ->
        # Build default path if version is provided
        case Keyword.get(opts, :version) do
          nil -> nil
          version -> ~c"$RELEASE_LIB/../releases/#{version}/consolidated"
        end

      path when is_binary(path) ->
        to_charlist(path)

      path when is_list(path) ->
        path
    end
  end

  defp add_consolidated_paths(instructions, consolidated_path) do
    updated = Enum.map(instructions, fn
      {:path, paths} when is_list(paths) ->
        # Prepend consolidated path to all path instructions
        {:path, [consolidated_path | paths]}

      other ->
        other
    end)

    {:ok, updated}
  end

  # Public API functions

  @doc """
  Process a script file and write the output.

  This is a convenience function that combines reading, processing, and writing.
  """
  def process_script_file(input_path, output_path, opts \\ []) do
    with {:ok, modified} <- process_script(input_path, opts),
         :ok <- write_script(modified, output_path) do
      # Generate .boot file if requested
      if Keyword.get(opts, :generate_boot, true) do
        script_to_boot(output_path)
      else
        :ok
      end
    end
  end
end