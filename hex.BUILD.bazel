load("@rules_elixir//private:elixir_bytecode.bzl", "elixir_bytecode")
load("@rules_elixir//:defs.bzl", "mix_library")

# load("@rules_erlang//:erlang_xrl_yrl.bzl", "erlang_xrl_yrl")
# load("@rules_erlang//:erlang_bytecode.bzl", "erlang_bytecode")
# load("@rules_erlang//:app_file2.bzl", "app_file")
# load("@rules_erlang//:erlang_app_info.bzl", "erlang_app_info")
# load("@rules_elixir//private:elixir_bytecode.bzl", "elixir_bytecode")

# mix_library(
#     name = "hex",
#     mix_config = ":mix.exs",
#     srcs = glob(["lib/**/*.ex"]),
#     data = ["lib/hex/http/ca-bundle.crt"],
#     deps = ["@rules_elixir//elioxir:mix"],
# )

# Step 1: Compile the .xrl file to .erl
# erlang_xrl_yrl(
#     name = "xrl_to_erl",
#     srcs = ["src/mix_safe_erl_term.xrl"],
#     outs = ["generated/mix_safe_erl_term.erl"],
# )
# 
# # Step 2: Compile Erlang sources (.erl files)
# # We need to include the generated .erl file from the .xrl compilation
# filegroup(
#     name = "erlang_srcs",
#     srcs = glob(["src/**/*.erl"]) + [":xrl_to_erl"],
# )
# 
# erlang_bytecode(
#     name = "erlang_beam_files",
#     srcs = [":erlang_srcs"],
#     hdrs = glob(["src/**/*.hrl"]),
#     dest = "erlang_ebin",
#     erlc_opts = [
#         "+deterministic",
#         "+debug_info",
#         "+warn_export_vars",
#         "+warn_shadow_vars",
#         "+warn_obsolete_guard",
#     ],
# )
# 
# # Step 3: Compile Elixir sources (.ex files)
# elixir_bytecode(
#     name = "elixir_beam_files",
#     srcs = glob(["lib/**/*.ex"]),
#     dest = "elixir_ebin",
#     elixirc_opts = [
#         "--ignore-module-conflict",
#     ],
#     deps = [
#         "@rules_elixir//elixir:mix",  # Mix is needed for Mix.Project calls in hex.ex
#     ],
# )
# 
# # Step 4: Create the .app file
# app_file(
#     name = "hex_app_file",
#     out = "hex.app",
#     app_name = "hex",
#     app_version = "2.2.2",
#     app_description = "Package manager for the Erlang ecosystem",
#     app_module = "Hex.Application",
#     extra_apps = [
#         "elixir",
#         "ssl",
#         "inets",
#         "logger",
#     ],
#     modules = [
#         ":erlang_beam_files",
#         ":elixir_beam_files",
#     ],
# )
# 
# # Step 5: Create the final erlang_app_info provider
# # We pass both Erlang and Elixir beam files separately
# # The erlang_app_info rule will handle combining them
# erlang_app_info(
#     name = "hex",
#     app_name = "hex",
#     srcs = glob([
#         "lib/**/*.ex",
#         "src/**/*.erl",
#     ]),
#     hdrs = glob(["src/**/*.hrl"]),
#     app = ":hex_app_file",
#     beam = [
#         ":erlang_beam_files",
#         ":elixir_beam_files",
#     ],
#     extra_apps = [
#         "ssl",
#         "inets",
#         "logger",
#     ],
#     deps = [],
#     visibility = ["//visibility:public"],
# )


