"""Elixir release rule that wraps erlang_release and adds Elixir-specific processing.

## What This Rule Does

The `elixir_release` rule creates an Elixir release by **wrapping** (not reimplementing)
`erlang_release` from rules_erlang_2 and adding Elixir-specific features on top. This is
an extension pattern, not code duplication.

## How It Works

### Phase 1: Base OTP Release Generation
The macro calls `erlang_release` from rules_erlang_2 to generate base release files using
OTP's standard `systools:make_script/2`:
- `{release_name}.rel` - Release specification
- `{release_name}.script` - Boot script (human-readable)
- `{release_name}.boot` - Binary boot file
- `{release_name}.manifest` - Application version map

### Phase 2: Elixir-Specific Post-Processing
The rule then processes the boot script with `boot_script_processor` to add:

1. **Config.Provider Support**: Injects `{:apply, {Config.Provider, :boot, []}}` into
   the boot script after stdlib initialization. This enables runtime configuration
   (reading environment variables, secrets at deployment time) - an Elixir feature
   not present in standard OTP releases.

2. **Consolidated Protocol Paths**: Prepends the consolidated protocols directory to
   the VM's code path. Protocol consolidation is an Elixir-specific optimization that
   improves protocol dispatch performance.

### Phase 3: ElixirReleaseInfo Provider
Returns `ElixirReleaseInfo` (which includes `ErlangReleaseInfo`) with metadata about:
- Runtime configuration status
- Consolidated protocols location
- Environment and version information

## How It Complements erlang_release

This rule **reuses** erlang_release rather than replacing it:

```python
def elixir_release(name, app, **kwargs):
    # 1. Generate base release using erlang_release
    _erlang_release_rule(
        name = "{}_base".format(name),
        app = app,
        **erlang_release_args
    )

    # 2. Post-process with Elixir features
    _elixir_release_rule(
        name = name,
        base_release = ":{}_base".format(name),
        **kwargs
    )
```

**Benefits of this approach**:
- Reuses all OTP tooling and logic from rules_erlang_2
- No pollution of rules_erlang with Elixir-specific concepts
- Automatic upstream improvements from rules_erlang_2
- Clean separation: Erlang base + Elixir extensions
- Follows the same pattern Mix itself uses (Mix also wraps systools)

**Interoperability**: Works seamlessly with mixed Erlang/Elixir projects because both
use the same `ErlangAppInfo` provider and OTP release structure.

## Why This Pattern?

Elixir releases **are** OTP releases with additional features. Rather than reimplementing
OTP's complex release generation (systools), we:
1. Use the standard OTP tooling via erlang_release
2. Post-process the output to add Elixir-specific features
3. Maintain full compatibility with OTP conventions

While it may seem kind of bonkers to modify the built release and partially rebuild it
to add in Elixir-specific extras, this is in fact what `mix release` itself does:
https://github.com/elixir-lang/elixir/blob/87cbf06ff1323fb4d67d1f3984120eef244e4005/lib/mix/lib/mix/release.ex#L628-L640

## When No Elixir Processing is Needed

If the release has no runtime configuration and no consolidated protocols, the rule
simply copies the erlang_release outputs without modification. This ensures Elixir
releases without Elixir-specific features are identical to pure Erlang releases.
"""

load("@rules_erlang//:erlang_release.bzl", "ErlangReleaseInfo")
load("@rules_erlang//:erlang_release.bzl", _erlang_release_rule = "erlang_release")
load("@rules_erlang//:erlang_app_info.bzl", "ErlangAppInfo")
load("//private:elixir_release_info.bzl", "ElixirReleaseInfo", "create_elixir_release_info")
load("//private:elixir_sys_config.bzl", "SysConfigInfo")
load("//private:protocol_consolidation.bzl", "ProtocolConsolidationInfo")
load(
    "//private:elixir_toolchain.bzl",
    "elixir_dirs",
    "erlang_dirs",
    "maybe_install_erlang",
)

def _elixir_release_impl(ctx):
    """Implementation of elixir_release rule."""

    # Get the app info
    app_info = ctx.attr.app[ErlangAppInfo]
    release_name = ctx.attr.release_name if ctx.attr.release_name else app_info.app_name
    release_version = ctx.attr.release_version if ctx.attr.release_version else "1.0.0"

    # --- Phase 1: Get the base Erlang release ---
    # The base release is generated by erlang_release through the macro
    erlang_release_info = ctx.attr.base_release[ErlangReleaseInfo]

    # --- Phase 2: Determine Elixir-specific configuration ---

    # Get sys_config information if provided
    sys_config_info = None
    has_runtime_config = False
    if ctx.attr.sys_config:
        sys_config_info = ctx.attr.sys_config[SysConfigInfo]
        has_runtime_config = sys_config_info.has_runtime_config

    # Get consolidated protocols information
    consolidated_dir = None
    if ctx.attr.consolidated_protocols:
        proto_info = ctx.attr.consolidated_protocols[ProtocolConsolidationInfo]
        consolidated_dir = proto_info.consolidated_dir

    # Determine whether to inject Config.Provider
    should_inject_config_provider = (
        ctx.attr.inject_config_provider and
        has_runtime_config
    )

    # Check if we need any Elixir processing at all
    needs_processing = (
        should_inject_config_provider or
        consolidated_dir != None
    )

    # If no Elixir processing is needed, create a directory with copies
    if not needs_processing:
        # Even without processing, we create a consistent directory structure
        release_dir = ctx.actions.declare_directory("{}_elixir_release".format(ctx.label.name))

        # Copy files without processing
        copy_script = """#!/bin/bash
set -euo pipefail
mkdir -p "{release_dir}"
cp "{rel_file}" "{release_dir}/{release_name}.rel"
cp "{script_file}" "{release_dir}/{release_name}.script"
cp "{boot_file}" "{release_dir}/{release_name}.boot"
cp "{manifest_file}" "{release_dir}/{release_name}.manifest"
""".format(
            release_dir = release_dir.path,
            rel_file = erlang_release_info.rel_file.path,
            script_file = erlang_release_info.script_file.path,
            boot_file = erlang_release_info.boot_file.path,
            manifest_file = erlang_release_info.manifest_file.path,
            release_name = release_name,
        )

        ctx.actions.run_shell(
            inputs = [
                erlang_release_info.rel_file,
                erlang_release_info.script_file,
                erlang_release_info.boot_file,
                erlang_release_info.manifest_file,
            ],
            outputs = [release_dir],
            command = copy_script,
            mnemonic = "ElixirReleaseCopy",
            progress_message = "Copying Elixir release files for {}".format(release_name),
        )

        return [
            DefaultInfo(
                files = depset([release_dir]),
            ),
            create_elixir_release_info(
                erlang_release_info = erlang_release_info,
                script_file = release_dir,
                boot_file = release_dir,
                sys_config_info = sys_config_info,
                runtime_config_files = ctx.files.runtime_config_files,
                env = ctx.attr.env,
            ),
            erlang_release_info,
        ]

    # --- Phase 3: Process boot script with Elixir modifications ---

    # Declare output directory for processed release files
    release_dir = ctx.actions.declare_directory("{}_elixir_release".format(ctx.label.name))

    # We'll process the files into this directory
    processed_script = "{}/{}.script".format(release_dir.path, release_name)
    processed_boot = "{}/{}.boot".format(release_dir.path, release_name)

    # Get boot_script_processor tool
    processor = ctx.executable._boot_script_processor
    (erlang_home, _, erlang_runfiles) = erlang_dirs(ctx)
    (elixir_home, elixir_runfiles) = elixir_dirs(ctx)

    # Build script to process the release files
    script_content = """#!/bin/bash
set -euo pipefail

{maybe_install_erlang}

# Set up paths
if [[ "{elixir_home}" == /* ]]; then
    ABS_ELIXIR_HOME="{elixir_home}"
else
    ABS_ELIXIR_HOME=$PWD/{elixir_home}
fi

if [[ "{erlang_home}" == /* ]]; then
    ABS_ERLANG_HOME="{erlang_home}"
else
    ABS_ERLANG_HOME=$PWD/{erlang_home}
fi

export PATH="$ABS_ELIXIR_HOME/bin:$ABS_ERLANG_HOME/bin:$PATH"

# Create output directory
mkdir -p "{release_dir}"

# Copy original files to the directory
cp "{rel_file}" "{release_dir}/{release_name}.rel"
cp "{script_file}" "{release_dir}/{release_name}.script"
cp "{boot_file}" "{release_dir}/{release_name}.boot"
cp "{manifest_file}" "{release_dir}/{release_name}.manifest"

# Make the script and boot files writable so we can process them
chmod +w "{release_dir}/{release_name}.script"
chmod +w "{release_dir}/{release_name}.boot"

# Build arguments for boot_script_processor
ARGS=()
ARGS+=("--input" "{release_dir}/{release_name}.script")
ARGS+=("--output" "{release_dir}/{release_name}.script")
ARGS+=("--version" "{release_version}")

{consolidated_args}
{config_provider_arg}

# Process the boot script in place
"{processor}" "${{ARGS[@]}}"

# Restore read-only permissions to maintain build output immutability
chmod -w "{release_dir}/{release_name}.script"
chmod -w "{release_dir}/{release_name}.boot"
""".format(
        maybe_install_erlang = maybe_install_erlang(ctx),
        elixir_home = elixir_home,
        erlang_home = erlang_home,
        processor = processor.path,
        release_dir = release_dir.path,
        rel_file = erlang_release_info.rel_file.path,
        script_file = erlang_release_info.script_file.path,
        boot_file = erlang_release_info.boot_file.path,
        manifest_file = erlang_release_info.manifest_file.path,
        release_name = release_name,
        release_version = release_version,
        consolidated_args = 'ARGS+=("--consolidated-path" "{}")'.format(
            ctx.attr.custom_consolidated_path if ctx.attr.custom_consolidated_path
            else "\\$RELEASE_LIB/../releases/{}/consolidated".format(release_version)
        ) if consolidated_dir else "# No consolidated protocols",
        config_provider_arg = 'ARGS+=("--no-config-provider")' if not should_inject_config_provider else "# Config.Provider enabled",
    )

    # Run the processing script
    ctx.actions.run_shell(
        inputs = depset(
            direct = [
                erlang_release_info.rel_file,
                erlang_release_info.script_file,
                erlang_release_info.boot_file,
                erlang_release_info.manifest_file,
                processor,
            ],
            transitive = [
                erlang_runfiles.files,
                elixir_runfiles.files,
            ],
        ),
        outputs = [release_dir],
        command = script_content,
        mnemonic = "ElixirBootScript",
        progress_message = "Processing Elixir boot script for {}".format(release_name),
    )

    # --- Phase 4: Create ElixirReleaseInfo provider ---

    # Create File references for the files in the directory
    # Note: We pass the directory since individual file references aren't available
    # The bundle rule will need to use the files from this directory

    elixir_release_info = create_elixir_release_info(
        erlang_release_info = erlang_release_info,
        script_file = release_dir,  # Pass the directory
        boot_file = release_dir,    # Pass the directory
        original_script_file = erlang_release_info.script_file,
        original_boot_file = erlang_release_info.boot_file,
        consolidated_protocols_dir = consolidated_dir,
        sys_config_info = sys_config_info,
        runtime_config_files = ctx.files.runtime_config_files,
        env = ctx.attr.env,
    )

    # --- Phase 5: Return providers ---

    return [
        DefaultInfo(
            files = depset([release_dir]),  # Return the directory
        ),
        elixir_release_info,
        # Also expose the underlying Erlang info for compatibility
        erlang_release_info,
    ]

# Private rule implementation
_elixir_release_rule = rule(
    implementation = _elixir_release_impl,
    attrs = {
        # --- Core Attributes ---

        "app": attr.label(
            mandatory = True,
            providers = [ErlangAppInfo],
            doc = """The main Elixir/Erlang application for this release.

            This can be any target that provides ErlangAppInfo, including:
            - mix_library targets (Elixir applications)
            - erlang_app targets (pure Erlang applications)

            Example:
                app = ":my_app"  # Built with mix_library
            """,
        ),

        # --- Release Configuration ---

        "release_name": attr.string(
            doc = """Override the release name.

            Defaults to the application name from ErlangAppInfo.
            This is the name used in generated files and commands.

            Example:
                release_name = "my_production_release"
            """,
        ),

        "release_version": attr.string(
            doc = """Release version string.

            Defaults to "1.0.0" if not specified.
            This version is used for:
            - Release directory structure (releases/{version}/)
            - Runtime config path construction
            - Version reporting

            Example:
                release_version = "2.3.4"
            """,
        ),

        "env": attr.string(
            default = "prod",
            values = ["prod", "dev", "test", "staging"],
            doc = """Build environment for the release.

            Affects configuration selection and optimization levels.
            Must match the environment used for sys_config if provided.
            """,
        ),

        # --- Elixir-Specific Features ---

        "consolidated_protocols": attr.label(
            providers = [ProtocolConsolidationInfo],
            doc = """Protocol consolidation target.

            If provided, adds consolidated protocol paths to the boot script.
            This is the output of elixir_protocol_consolidation rule.

            Example:
                consolidated_protocols = ":consolidated_protocols"
            """,
        ),

        "sys_config": attr.label(
            providers = [SysConfigInfo],
            doc = """System configuration target from elixir_sys_config rule.

            Provides compile-time and runtime configuration for the release.
            If this has runtime config, Config.Provider support will be enabled.

            Example:
                sys_config = ":sys_config_prod"
            """,
        ),

        "runtime_config_files": attr.label_list(
            allow_files = [".exs"],
            default = [],
            doc = """Additional runtime configuration files to include.

            These files will be copied to releases/{version}/ in the bundle.
            Typically this is runtime.exs but can include other .exs files.

            Example:
                runtime_config_files = ["config/runtime.exs"]
            """,
        ),

        # --- Boot Script Processing Options ---

        "inject_config_provider": attr.bool(
            default = True,
            doc = """Whether to inject Config.Provider boot call.

            Set to False to disable Config.Provider support even if runtime
            config is present. This is useful for minimal releases or when
            using custom configuration mechanisms.

            Default: True (inject if runtime config present)
            """,
        ),

        "custom_consolidated_path": attr.string(
            doc = """Custom path template for consolidated protocols.

            By default, uses: $RELEASE_LIB/../releases/{version}/consolidated

            Override this if you have a non-standard release structure.
            Supports environment variable expansion.

            Example:
                custom_consolidated_path = "$RELEASE_ROOT/consolidated"
            """,
        ),

        # --- Erlang Release Passthrough ---

        "extra_apps": attr.string_list(
            default = [],
            doc = """Additional OTP applications to include in the release.

            These are standard library apps that aren't dependencies but
            are needed at runtime. Common examples:
            - "compiler" (for runtime code generation)
            - "crypto" (for cryptographic operations)
            - "ssl" (for TLS support)
            - "tools" (for debugging)

            Example:
                extra_apps = ["compiler", "crypto", "ssl"]
            """,
        ),

        "app_version": attr.string(
            doc = """Override the application version.

            Defaults to version from the app's .app file.
            Rarely needed - prefer setting version in mix.exs or .app.src
            """,
        ),

        # --- Internal Attributes ---

        "base_release": attr.label(
            mandatory = True,
            providers = [ErlangReleaseInfo],
            doc = "Internal: Base erlang_release target (set by macro)",
        ),

        "_boot_script_processor": attr.label(
            default = Label("//tools/boot_script_processor"),
            executable = True,
            cfg = "exec",
            doc = "Internal: Boot script processor escript",
        ),
    },
    provides = [DefaultInfo, ElixirReleaseInfo, ErlangReleaseInfo],
    toolchains = ["//:toolchain_type"],
    doc = """Create an Elixir release with boot script post-processing.

    This rule wraps erlang_release from rules_erlang_2 and adds Elixir-specific
    functionality:

    1. Generates base release files using erlang_release
    2. Post-processes boot script with boot_script_processor to add:
       - Config.Provider support (for runtime configuration)
       - Consolidated protocol paths
    3. Produces ElixirReleaseInfo for use by elixir_release_bundle

    Example:
        elixir_release(
            name = "my_release",
            app = ":my_app",
            release_version = "1.0.0",
            consolidated_protocols = ":consolidated_protocols",
            sys_config = ":sys_config_prod",
            extra_apps = ["crypto", "ssl"],
        )

    This generates:
        - my_release.rel (release specification)
        - my_release.script (processed boot script)
        - my_release.boot (processed boot file)
        - my_release.manifest (app versions)
    """,
)

def elixir_release(name, app, **kwargs):
    """Macro that generates erlang_release and wraps it with elixir_release_rule.

    This macro simplifies usage by automatically creating the base erlang_release
    target and then wrapping it with Elixir-specific processing.

    Args:
        name: Name of the release target
        app: The main application target
        **kwargs: Additional arguments passed to both erlang_release and elixir_release_rule
    """

    # Extract arguments for erlang_release
    erlang_release_args = {}
    if "release_name" in kwargs:
        erlang_release_args["release_name"] = kwargs["release_name"]
    if "release_version" in kwargs:
        erlang_release_args["release_version"] = kwargs["release_version"]
    if "app_version" in kwargs:
        erlang_release_args["app_version"] = kwargs["app_version"]

    # For extra_apps, we should automatically include elixir and logger
    # Plus any user-specified ones
    base_extra_apps = ["elixir", "logger", "kernel", "stdlib"]
    if "extra_apps" in kwargs:
        # Merge user's extra_apps with base requirements
        user_apps = kwargs["extra_apps"]
        # Deduplicate
        all_apps = list(set(base_extra_apps + user_apps))
        erlang_release_args["extra_apps"] = all_apps
    else:
        erlang_release_args["extra_apps"] = base_extra_apps

    # Generate base erlang_release
    _erlang_release_rule(
        name = "{}_base".format(name),
        app = app,
        tags = ["manual"],  # Don't build directly
        **erlang_release_args
    )

    # Generate elixir_release that processes the base
    _elixir_release_rule(
        name = name,
        app = app,
        base_release = ":{}_base".format(name),
        **kwargs
    )
